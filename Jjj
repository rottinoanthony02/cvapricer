# =========================
# Tab 3 — Régimes HMM multivarié sur constituants (Standardisation obligatoire, pas de PCA)
# =========================
try:
    st.subheader("Régimes (HMM) sur les **constituants** + Hedge piloté par probabilité de stress")

    # --- Paramètres HMM & Hedge ---
    c1, c2, c3, c4 = st.columns(4)
    with c1:
        hmm_states = st.slider("Nb régimes (HMM)", 2, 6, 3, 1, key="tab3_hmm_states")
    with c2:
        n_iter = st.number_input("n_iter (EM)", 50, 2000, 300, 50, key="tab3_hmm_niter")
    with c3:
        topN = st.slider("Top N constituants par jour", 1, 20, 4, 1, key="tab3_topN")
    with c4:
        apply_day = st.selectbox("Appliquer le hedge", ["Jour T", "Jour T+1"], index=0, key="tab3_apply_day")

    d1, d2, d3 = st.columns(3)
    with d1:
        tau1 = st.slider("τ1 (→ α=0.3)", 0.0, 1.0, 0.50, 0.05, key="tab3_tau1")
    with d2:
        tau2 = st.slider("τ2 (→ α=0.6)", 0.0, 1.0, 0.70, 0.05, key="tab3_tau2")
    with d3:
        tau3 = st.slider("τ3 (→ α=1.0)", 0.0, 1.0, 0.85, 0.05, key="tab3_tau3")

    e1, e2, e3 = st.columns(3)
    with e1:
        cost_rate = st.number_input("Coût — Rates (par DV01)", 0.0, 5.0, 0.20, 0.01, key="tab3_cost_rate")
    with e2:
        cost_xccy = st.number_input("Coût — XCCY (par DV01)", 0.0, 5.0, 0.25, 0.01, key="tab3_cost_xccy")
    with e3:
        cost_fx   = st.number_input("Coût — FX (par FX01)",   0.0, 5.0, 0.00, 0.01, key="tab3_cost_fx")

    def alpha_from_p(p: float) -> float:
        if not np.isfinite(p):
            return 0.0
        if p < tau1: return 0.0
        if p < tau2: return 0.3
        if p < tau3: return 0.6
        return 1.0

    # --- HMM multivarié sur les contributions par constituant (Standardisation obligatoire) ---
    from hmmlearn.hmm import GaussianHMM
    from sklearn.preprocessing import StandardScaler

    X_df = pnl_by_factor.copy().replace([np.inf, -np.inf], np.nan).dropna(how="any")
    idx_obs = X_df.index

    scaler = StandardScaler()
    X_use = scaler.fit_transform(X_df.values)

    hmm = GaussianHMM(n_components=int(hmm_states), covariance_type='full', n_iter=int(n_iter), random_state=42)
    hmm.fit(X_use)
    states = pd.Series(hmm.predict(X_use), index=idx_obs, name="state")
    post = pd.DataFrame(hmm.predict_proba(X_use), index=idx_obs, columns=[f"Regime {i}" for i in range(int(hmm_states))])

    # Identifier le régime stress par moyenne de NetDailyPnL la plus faible
    net_on_state = pd.concat([net_daily.reindex(idx_obs), states], axis=1).dropna()
    means_by_state = net_on_state.groupby('state')['NetDailyPnL'].mean()
    stress_regime = int(means_by_state.idxmin()) if len(means_by_state)>0 else 0
    hmm_proba_stress = post.iloc[:, stress_regime].rename("hmm_proba_stress")

    # Détecter les entrées en stress
    entries = []
    prev = None
    for dt, lab in states.items():
        if prev is None:
            prev = lab; continue
        if (lab == stress_regime) and (prev != stress_regime):
            entries.append(dt)
        prev = lab

    # --- Graphique HMM ---
    figR, axR = plt.subplots(figsize=(12,5), dpi=120)
    axR.plot(net_daily.index, net_daily.values, lw=1.1, label='PnL quotidien')
    cmap = plt.cm.get_cmap('tab10', int(hmm_states))
    for s_id in range(int(hmm_states)):
        mask = states == s_id
        axR.fill_between(net_daily.index, net_daily.values, 0,
                         where=mask.reindex(net_daily.index).fillna(False),
                         color=cmap(s_id), alpha=0.12, label=f'Regime {s_id}')
    if len(entries):
        axR.vlines(entries, ymin=min(float(net_daily.min()),0.0), ymax=max(float(net_daily.max()),0.0),
                   linestyles=':', color='black', alpha=0.5, label='Entrée stress')
    format_yaxis_plain(axR); auto_xticks(axR, net_daily.index)
    axR.set_title('HMM multivarié (constituants) — Régimes & entrées stress (standardisé)')
    axR.legend(loc='upper left', ncols=2)
    st.pyplot(figR)

    # --- Plan de hedge piloté par proba HMM (standardisation obligatoire) ---
    risk_cols_loc = list(pnl_by_factor.columns)
    bump_s = mapping_df.reindex(risk_cols_loc)["Bump"].astype(float).where(lambda s: s.notna() & (s != 0.0))

    def _bucket(name: str) -> str:
        n = str(name).upper()
        if 'FX' in n or (name in FX_COLS): return 'FX'
        if 'XCCY' in n or 'BASIS' in n: return 'XCCY'
        return 'Rates'

    contrib_after = pnl_by_factor.copy()
    cost_series = pd.Series(0.0, index=pnl_by_factor.index)
    plan_rows = []

    proba_series = hmm_proba_stress.reindex(pnl_by_factor.index).fillna(method='ffill')

    for d in pnl_by_factor.index:
        p = float(proba_series.get(d, 0.0))
        a = float(alpha_from_p(p))
        if a <= 0:
            continue
        pnl_row = pnl_by_factor.loc[d].reindex(risk_cols_loc)
        top_names = pnl_row.abs().sort_values(ascending=False).head(int(topN)).index.tolist()

        target_day = d if apply_day == "Jour T" else (d + pd.Timedelta(days=1))
        if target_day in contrib_after.index:
            contrib_after.loc[target_day, top_names] = contrib_after.loc[target_day, top_names] * (1.0 - a)

        for cst in top_names:
            pnl_c  = float(pnl_row.get(cst, 0.0))
            bump_c = float(bump_s.get(cst, np.nan))
            if not np.isfinite(bump_c) or abs(bump_c) < 1e-12:
                hedge_units = np.nan; unit_cost = 0.0
            else:
                hedge_units = -(a * (pnl_c / bump_c))
                bucket = _bucket(cst)
                unit_cost = cost_fx if bucket == 'FX' else (cost_xccy if bucket == 'XCCY' else cost_rate)

            if target_day in cost_series.index and np.isfinite(hedge_units):
                cost_series.loc[target_day] += abs(hedge_units) * float(unit_cost)

            plan_rows.append({
                "Date": target_day,
                "p_HMM_stress": p,
                "alpha": a,
                "Constituant": cst,
                "PnL_contrib": pnl_c,
                "Bump": bump_c,
                "HedgeUnits": hedge_units,
                "Bucket": _bucket(cst),
                "UnitCost": unit_cost,
                "CostAlloc": (abs(hedge_units)*float(unit_cost)) if np.isfinite(hedge_units) else 0.0,
            })

    plan_df = pd.DataFrame(plan_rows)

    # --- PnL baseline vs hedgé ---
    pnl_base  = pnl_by_factor.sum(axis=1).rename("PnL_baseline")
    pnl_after = contrib_after.sum(axis=1).rename("PnL_gross_after") - cost_series.rename("HedgeCost").reindex(pnl_by_factor.index).fillna(0.0)
    cum_base  = pnl_base.cumsum().rename("Cum_Base")
    cum_after = pnl_after.cumsum().rename("Cum_Hedged")

    figF, axF = plt.subplots(figsize=(12,5), dpi=120)
    axF.plot(cum_base.index,  cum_base.values,  label="Cumul Base")
    axF.plot(cum_after.index, cum_after.values, label="Cumul Hedgé")
    format_yaxis_plain(axF); auto_xticks(axF, cum_after.index)
    axF.set_title("Cumulative PnL — Base vs Hedgé (HMM multivarié standardisé)")
    axF.legend(loc='upper left')
    st.pyplot(figF)

    k1, k2, k3 = st.columns(3)
    with k1: st.metric("Δ Cumul (Hedgé-Base)", f"{float(cum_after.iloc[-1]-cum_base.iloc[-1]):,.0f}")
    with k2: st.metric("Coût total hedge", f"{float(cost_series.sum()):,.0f}")
    with k3: st.metric("% jours α>0", f"{100.0*float((proba_series.apply(alpha_from_p)>0).mean()):.1f}%")

    st.subheader("Plan de hedge (HMM sur constituants — standardisé)")
    if plan_df.empty:
        st.info("Aucun hedge déclenché (probabilité de stress trop faible).")
    else:
        st.dataframe(
            plan_df.sort_values(["Date","Constituant"])
                   .style.format({
                       "p_HMM_stress":"{:.2f}", "alpha":"{:.2f}",
                       "PnL_contrib":"{:,.0f}", "Bump":"{:,.6f}",
                       "HedgeUnits":"{:,.0f}", "UnitCost":"{:,.3f}",
                       "CostAlloc":"{:,.0f}"
                   }).applymap(lambda v: 'color:red;' if isinstance(v,(int,float)) and v<0 else '',
                               subset=['PnL_contrib','HedgeUnits','CostAlloc']),
            use_container_width=True, height=420
        )
        st.download_button(
            "Télécharger (CSV) — Plan de hedge (HMM constituants)",
            data=plan_df.to_csv(index=False).encode('utf-8'),
            file_name="hmm_multivar_hedge_plan.csv",
            mime="text/csv"
        )

    # --- Table Top-N par dates d'entrée en stress ---
    st.subheader("Entrées en régime stress — Top N constituants & tailles de hedge")
    rows = []
    for d in [*entries]:
        if d not in pnl_by_factor.index: continue
        pnl_row = pnl_by_factor.loc[d].reindex(risk_cols_loc)
        top_names = pnl_row.abs().sort_values(ascending=False).head(int(topN)).index.tolist()
        a_d = float(alpha_from_p(float(hmm_proba_stress.get(d, 0.0))))
        for cst in top_names:
            pnl_c  = float(pnl_row.get(cst, np.nan))
            bump_c = float(bump_s.get(cst, np.nan))
            hedge_units = (-(a_d * (pnl_c / bump_c)) if np.isfinite(bump_c) and abs(bump_c)>1e-12 else np.nan)
            rows.append({
                "Date": d,
                "Constituant": cst,
                "PnL_contrib": pnl_c,
                "Bump": bump_c,
                "alpha(d)": a_d,
                "HedgeUnits": hedge_units,
            })
    tbl_entries = pd.DataFrame(rows)
    if tbl_entries.empty:
        st.info("Aucune entrée stress détectée ou données insuffisantes.")
    else:
        tbl_entries["Abs"] = tbl_entries["PnL_contrib"].abs()
        tbl_entries = tbl_entries.sort_values(["Date","Abs"], ascending=[True, False]).drop(columns=["Abs"])
        st.dataframe(tbl_entries.style.format({
            "PnL_contrib":"{:,.0f}", "Bump":"{:,.6f}", "alpha(d)":"{:.2f}", "HedgeUnits":"{:,.0f}"
        }), use_container_width=True)
        st.download_button(
            "Télécharger (CSV) — Entrées stress (TopN)",
            data=tbl_entries.to_csv(index=False).encode('utf-8'),
            file_name="hmm_multivar_entries_topN.csv",
            mime="text/csv"
        )

except Exception as _e_tab3_hmm:
    st.warning(f"Tab 3 (HMM multivarié standardisé) non rendue: {_e_tab3_hmm}")
