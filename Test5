# =========================
# TAB 3 — KNN (régimes) + Hedge basé sur ΔS
# Somme de tous les scénarios (analyse sur le total)
# =========================
with tab3:
    st.header("KNN — Régimes & Hedge basé sur ΔS (Total des scénarios)")

    # --- Paramètres ---
    c1, c2, c3 = st.columns(3)
    with c1:
        n_neighbors_knn = st.slider("KNN — n_neighbors", 2, 15, 5)
    with c2:
        top_n = st.slider("Top N constituants par date", 1, 20, 4)
    with c3:
        alpha_cov = st.slider("α — % à couvrir", 0, 100, 100, 5)/100.0

    # ---------- Coeff total = somme de tous les scénarios ----------
    coeff_cols_all = [c for c in coeff_df.columns if c != "DataType"]
    # somme des scénarios par constituant (DataType) puis alignement aux risk_cols
    coeff_total = (
        coeff_df.set_index("DataType")[coeff_cols_all]
        .astype(float)
        .sum(axis=1)
        .reindex(risk_cols)
    )
    bump_s = (
        mapping_df.reindex(risk_cols)["Bump"]
        .astype(float)
        .replace(0.0, np.nan)
    )
    dv01_per_unit_total = (coeff_total / bump_s).replace([np.inf, -np.inf], np.nan)

    # ---------- KNN sur contributions (regimes via signe du PnL net) ----------
    X = pnl_by_factor.fillna(0.0)
    scaler = StandardScaler()
    Xz = scaler.fit_transform(X)
    y = np.where(net_daily.reindex(X.index).fillna(0.0).values >= 0.0, 1, -1)

    knn = KNeighborsClassifier(n_neighbors=n_neighbors_knn)
    knn.fit(Xz, y)
    y_hat = knn.predict(Xz)
    labels_knn = pd.Series(y_hat, index=X.index, name="Regime")

    # Dates d'entrée en régime négatif
    entries = []
    prev = None
    for dt, lab in labels_knn.items():
        if prev is None:
            prev = lab; continue
        if (lab < 0) and (lab != prev):
            entries.append(dt)
        prev = lab

    # ---------- Graphique régimes ----------
    figR, axR = plt.subplots(figsize=(12,5), dpi=120)
    axR.plot(net_daily.index, net_daily.values, lw=1.1, label="PnL quotidien")
    axR.fill_between(net_daily.index, net_daily.values, 0, where=(labels_knn.values < 0),
                     color="red", alpha=0.18, label="Régime négatif")
    for d in entries:
        axR.axvline(d, color="red", linestyle=":", alpha=0.6)
    axR.yaxis.set_major_formatter(FuncFormatter(lambda v,_: f"{v:,.0f}"))
    # Axe X adaptatif
    npts=len(net_daily)
    if npts<120:
        locx=mdates.MonthLocator(interval=1); fmtx=mdates.DateFormatter('%b %Y')
    elif npts<300:
        locx=mdates.MonthLocator(interval=3); fmtx=mdates.DateFormatter('%b %Y')
    elif npts<700:
        locx=mdates.MonthLocator(interval=6); fmtx=mdates.DateFormatter('%b %Y')
    else:
        locx=mdates.YearLocator(); fmtx=mdates.DateFormatter('%Y')
    axR.xaxis.set_major_locator(locx); axR.xaxis.set_major_formatter(fmtx)
    axR.set_title("KNN — PnL & Régimes (zones rouges = négatif)")
    axR.legend(loc="upper left")
    st.pyplot(figR)

    # ---------- Table Top-N par entrée (hedge = −PnL/ΔS) ----------
    rows = []
    for d in entries:
        if d not in pnl_by_factor.index or d not in mkt_change.index:
            continue
        pnl_row = pnl_by_factor.loc[d].reindex(risk_cols)
        dS_row  = mkt_change.loc[d].reindex(risk_cols)
        topN = pnl_row.abs().sort_values(ascending=False).head(top_n).index

        for c in topN:
            pnl_c = float(pnl_row.get(c, np.nan))
            dS_c  = float(dS_row.get(c, np.nan))
            bump_c = float(bump_s.get(c, np.nan))
            coeff_tot_c = float(coeff_total.get(c, np.nan))
            dv01_unit_tot = float(dv01_per_unit_total.get(c, np.nan))
            # Hedge 100% basé sur le move observé ΔS : DV01/FX01 = −PnL/ΔS
            hedge_100 = -(pnl_c / dS_c) if (np.isfinite(dS_c) and abs(dS_c)>1e-12) else np.nan
            hedge_alpha = hedge_100 * alpha_cov if np.isfinite(hedge_100) else np.nan

            rows.append({
                "Date": d,
                "Constituant": c,
                "PnL_contrib": pnl_c,
                "ΔS (move observé)": dS_c,
                "Bump (Mapping)": bump_c,                     # info
                "Coeff_total (∑ scénarios)": coeff_tot_c,      # info
                "DV01/FX01 per-unit (Coeff_total/Bump)": dv01_unit_tot,  # info
                "Hedge100% (−PnL/ΔS)": hedge_100,             # utilisé pour le hedge
                "Hedge(α×)": hedge_alpha
            })

    tbl_knn = pd.DataFrame(rows).sort_values(["Date","Constituant"]) if rows else pd.DataFrame()

    st.subheader("Top N — dates d’entrée négative & hedge basé sur ΔS (Total scénarios)")
    if tbl_knn.empty:
        st.info("Aucune entrée détectée ou données insuffisantes.")
    else:
        st.dataframe(
            tbl_knn.style.format({
                "PnL_contrib": "{:,.0f}",
                "ΔS (move observé)": "{:,.6f}",
                "Bump (Mapping)": "{:,.6f}",
                "Coeff_total (∑ scénarios)": "{:,.0f}",
                "DV01/FX01 per-unit (Coeff_total/Bump)": "{:,.0f}",
                "Hedge100% (−PnL/ΔS)": "{:,.0f}",
                "Hedge(α×)": "{:,.0f}",
            }).applymap(lambda v: "color:red;" if isinstance(v,(int,float)) and v<0 else "",
                        subset=["PnL_contrib", "Hedge100% (−PnL/ΔS)", "Hedge(α×)"]),
            use_container_width=True
        )
        st.download_button(
            "Télécharger (CSV) — KNN & Hedge(−PnL/ΔS) — Total scénarios",
            data=tbl_knn.to_csv(index=False).encode("utf-8"),
            file_name=f"knn_entries_hedge_deltaS_total_{dtype}.csv",
            mime="text/csv",
        )

    # ---------- Coûts & PnL net (compact) ----------
    st.subheader("Coût de hedge et PnL net (Total scénarios)")
    c1, c2, c3 = st.columns(3)
    cost_rate = c1.number_input("Coût — Rates (par DV01)", 0.0, 5.0, 0.20)
    cost_xccy = c2.number_input("Coût — XCCY (par DV01)", 0.0, 5.0, 0.25)
    cost_fx   = c3.number_input("Coût — FX (par FX01)",   0.0, 5.0, 0.00)

    def _bucket(name: str) -> str:
        n = str(name).upper()
        if "FX" in n or (name in FX_COLS):
            return "FX"
        if "XCCY" in n or "BASIS" in n:
            return "XCCY"
        return "Rates"

    cost_series = pd.Series(0.0, index=net_daily.index)
    for d, sub in tbl_knn.groupby("Date"):
        tot = 0.0
        for _, r in sub.iterrows():
            units = r.get("Hedge(α×)", np.nan)
            if not np.isfinite(units) or units == 0:
                continue
            b = _bucket(r.get("Constituant",""))
            if b == "FX":
                tot += abs(units) * float(cost_fx)
            elif b == "XCCY":
                tot += abs(units) * float(cost_xccy)
            else:
                tot += abs(units) * float(cost_rate)
        if d in cost_series.index:
            cost_series.loc[d] += tot

    # Appliquer α sur le PnL des constituants concernés le jour d'entrée
    contrib_after = pnl_by_factor.copy()
    for d, sub in tbl_knn.groupby("Date"):
        if d not in contrib_after.index:
            continue
        cols = sub["Constituant"].unique().tolist()
        contrib_after.loc[d, cols] = contrib_after.loc[d, cols] * (1.0 - float(alpha_cov))

    pnl_base  = pnl_by_factor.sum(axis=1).rename("PnL_baseline")
    pnl_hedge = (contrib_after.sum(axis=1) - cost_series).rename("PnL_hedged_net")

    fig_net, ax_net = plt.subplots(figsize=(12,5), dpi=120)
    ax_net.plot(pnl_base.cumsum(),  label="Baseline")
    ax_net.plot(pnl_hedge.cumsum(), label="Hedged (net coût)")
    if len(entries):
        ax_net.vlines(entries,
                      ymin=min(float(pnl_base.cumsum().min()), float(pnl_hedge.cumsum().min())),
                      ymax=max(float(pnl_base.cumsum().max()), float(pnl_hedge.cumsum().max())),
                      linestyles=":", color="red", alpha=0.35, label="Entrées négatives")
    ax_net.yaxis.set_major_formatter(FuncFormatter(lambda v,_: f"{v:,.0f}"))
    ax_net.set_title("Cumulative PnL — Baseline vs Hedged (net coût) — Total scénarios")
    ax_net.legend(loc="upper left")
    st.pyplot(fig_net)

    # KPIs
    tot_cost = float(cost_series.sum())
    pnl_diff = float(pnl_hedge.cumsum().iloc[-1] - pnl_base.cumsum().iloc[-1])
    k1, k2 = st.columns(2)
    with k1: st.metric("Coût total hedge", f"{tot_cost:,.0f}")
    with k2: st.metric("Δ PnL cumulé (Hedged - Baseline)", f"{pnl_diff:,.0f}")
