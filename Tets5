# =========================
# TAB 3 — Régimes HMM + Signal Rules (HMM / Jump / Vol) + Cross-Hedge (LinearRegression)
# =========================
with tab3:
    try:
        st.subheader("Régimes (HMM) + Signal Rules (HMM / Jump / Vol) + Cross-Hedge (LinearRegression)")

        # --- Paramètres HMM & Hedge ---
        c1, c2, c3, c4 = st.columns(4)
        with c1:
            hmm_states = st.slider("Nb régimes (HMM)", 2, 6, 3, 1)
        with c2:
            n_iter = st.number_input("n_iter (EM)", 50, 2000, 300, 50)
        with c3:
            topN = st.slider("Top N constituants / jour", 1, 20, 4, 1)
        with c4:
            apply_day = st.selectbox("Appliquer le hedge", ["Jour T", "Jour T+1"], index=0)

        # --- Seuils → α ---
        d1, d2, d3 = st.columns(3)
        with d1:
            tau1 = st.slider("Seuil τ1 (→ α=0.3)", 0.0, 1.0, 0.50, 0.05)
        with d2:
            tau2 = st.slider("Seuil τ2 (→ α=0.6)", 0.0, 1.0, 0.70, 0.05)
        with d3:
            tau3 = st.slider("Seuil τ3 (→ α=1.0)", 0.0, 1.0, 0.85, 0.05)

        # --- Coûts de hedge ---
        e1, e2, e3 = st.columns(3)
        with e1:
            cost_rate = st.number_input("Coût — Rates (par DV01)", 0.0, 5.0, 0.20, 0.01)
        with e2:
            cost_xccy = st.number_input("Coût — XCCY (par DV01)", 0.0, 5.0, 0.25, 0.01)
        with e3:
            cost_fx   = st.number_input("Coût — FX (par FX01)",   0.0, 5.0, 0.00, 0.01)

        # --- Cross-hedge controls ---
        x1, x2, x3 = st.columns(3)
        with x1:
            use_cross = st.checkbox("Activer cross-hedge (XCCY → proxy Rates/FX)", value=True)
        with x2:
            win_corr  = st.slider("Fenêtre corr (jours)", 20, 180, 60, 5)
        with x3:
            min_abs_corr = st.slider("Seuil |corr| min", 0.0, 1.0, 0.40, 0.05)
        with st.expander("Paramètres avancés cross-hedge", expanded=False):
            min_r2 = st.slider("Seuil R² minimum", 0.0, 1.0, 0.30, 0.05)

        # --- HMM multivarié ---
        from hmmlearn.hmm import GaussianHMM
        from sklearn.preprocessing import StandardScaler

        X_df = pnl_by_factor.copy().replace([np.inf, -np.inf], np.nan).dropna(how="any")
        idx_obs = X_df.index

        scaler = StandardScaler()
        X_use = scaler.fit_transform(X_df.values)

        hmm = GaussianHMM(n_components=int(hmm_states), covariance_type='full', n_iter=int(n_iter), random_state=42)
        hmm.fit(X_use)
        states = pd.Series(hmm.predict(X_use), index=idx_obs, name="state")
        post = pd.DataFrame(hmm.predict_proba(X_use), index=idx_obs)

        net_on_state = pd.concat([net_daily.reindex(idx_obs), states], axis=1).dropna()
        means_by_state = net_on_state.groupby('state')['NetDailyPnL'].mean()
        stress_regime = int(means_by_state.idxmin()) if len(means_by_state)>0 else 0
        p_stress = post.iloc[:, stress_regime].rename("p_stress")

        # Graphique régimes
        figR, axR = plt.subplots(figsize=(12,5), dpi=120)
        axR.plot(net_daily.index, net_daily.values, lw=1.1, label='PnL quotidien')
        cmap = plt.cm.get_cmap('tab10', int(hmm_states))
        for s_id in range(int(hmm_states)):
            mask = states == s_id
            axR.fill_between(net_daily.index, net_daily.values, 0,
                             where=mask.reindex(net_daily.index).fillna(False),
                             color=cmap(s_id), alpha=0.12, label=f'Regime {s_id}')
        axR.set_title('HMM multivarié — Régimes (standardisé)')
        axR.legend(loc='upper left', ncols=2)
        st.pyplot(figR)

        # --- Règle de signal → α (HMM global / Jump / Vol) ---
        sig_mode = st.selectbox("Règle de signal", ["HMM (global)", "Jump (par constituant)", "Vol (par constituant)"], index=0)
        if sig_mode != "HMM (global)":
            win_sig = st.slider("Fenêtre signal (jours)", 10, 120, 20, 5)

        def map_alpha_scalar(x: float) -> float:
            if not np.isfinite(x): return 0.0
            if x < tau1: return 0.0
            if x < tau2: return 0.3
            if x < tau3: return 0.6
            return 1.0

        alpha_global, alpha_df, sig_df = None, None, None
        if sig_mode == "HMM (global)":
            alpha_global = p_stress.reindex(pnl_by_factor.index).apply(map_alpha_scalar)
        elif sig_mode == "Jump (par constituant)":
            eps = 1e-12
            diff_abs = pnl_by_factor.diff().abs()
            med_roll = pnl_by_factor.rolling(win_sig, min_periods=max(5, win_sig//2)).median()
            mad_roll = (pnl_by_factor - med_roll).abs().rolling(win_sig, min_periods=max(5, win_sig//2)).median()
            sig_df = (diff_abs / (mad_roll + eps)).fillna(0.0)
            sig_df = sig_df.apply(lambda s: (s - s.min()) / (s.max() - s.min() + eps))
            alpha_df = pd.DataFrame(index=pnl_by_factor.index, columns=pnl_by_factor.columns, dtype=float)
            alpha_df[sig_df < tau1] = 0.0
            alpha_df[(sig_df >= tau1) & (sig_df < tau2)] = 0.3
            alpha_df[(sig_df >= tau2) & (sig_df < tau3)] = 0.6
            alpha_df[sig_df >= tau3] = 1.0
        else:
            eps = 1e-12
            std_roll = pnl_by_factor.rolling(win_sig, min_periods=max(5, win_sig//2)).std()
            sig_df = std_roll.apply(lambda s: (s - s.min()) / (s.max() - s.min() + eps)).fillna(0.0)
            alpha_df = pd.DataFrame(index=pnl_by_factor.index, columns=pnl_by_factor.columns, dtype=float)
            alpha_df[sig_df < tau1] = 0.0
            alpha_df[(sig_df >= tau1) & (sig_df < tau2)] = 0.3
            alpha_df[(sig_df >= tau2) & (sig_df < tau3)] = 0.6
            alpha_df[sig_df >= tau3] = 1.0

        # --- Hedge simulation ---
        from sklearn.linear_model import LinearRegression
        cost_series = pd.Series(0.0, index=pnl_by_factor.index)
        plan_rows = []  # <— CORRECT: unique container

        def _bucket(name: str) -> str:
            u = str(name).upper()
            if 'FX' in u or (name in FX_COLS): return 'FX'
            if 'XCCY' in u or 'BASIS' in u:     return 'XCCY'
            return 'Rates'

        risk_cols_loc = list(pnl_by_factor.columns)
        risk_ts_loc   = risk_ts.reindex(pnl_by_factor.index).reindex(columns=risk_cols_loc)

        for d in pnl_by_factor.index:
            pnl_row   = pnl_by_factor.loc[d].reindex(risk_cols_loc)
            top_names = pnl_row.abs().sort_values(ascending=False).head(int(topN)).index.tolist()

            # α (global ou par constituant) + stress à logger
            if alpha_df is not None:
                a_row = alpha_df.loc[d].fillna(0.0)
                s_row = sig_df.loc[d] if sig_df is not None else pd.Series(index=risk_cols_loc, dtype=float)
            else:
                a_row = pd.Series(alpha_global.get(d, 0.0) if alpha_global is not None else 0.0,
                                  index=risk_cols_loc, dtype=float)
                s_row = pd.Series(float(p_stress.get(d, np.nan)), index=risk_cols_loc)

            target_day = d if apply_day == "Jour T" else (d + pd.Timedelta(days=1))

            # Fenêtre de régression sur Δmarket
            if use_cross:
                w_start = d - pd.Timedelta(days=int(win_corr)-1)
                window_idx = pnl_by_factor.index[(pnl_by_factor.index >= w_start) & (pnl_by_factor.index <= d)]
                mkt_win = mkt_change.reindex(window_idx).reindex(columns=risk_cols_loc).dropna(how="any")
            else:
                mkt_win = None

            for c_target in top_names:
                r2_score_val = np.nan
                used_proxy = c_target
                gamma = 1.0

                risk_c = float(risk_ts_loc.loc[d, c_target]) if (c_target in risk_ts_loc.columns and d in risk_ts_loc.index) else np.nan
                a_ct   = float(a_row.get(c_target, 0.0))
                stress_val = float(s_row.get(c_target, np.nan)) if not pd.isna(s_row.get(c_target, np.nan)) else float(p_stress.get(d, np.nan))

                # Cross-hedge (XCCY seulement) via régression sur Δmarket
                if use_cross and (('XCCY' in str(c_target).upper()) or ('BASIS' in str(c_target).upper())) \
                   and (mkt_win is not None) and (len(mkt_win) >= max(15, int(win_corr)//2)) \
                   and (c_target in mkt_win.columns):

                    y_m = mkt_win[c_target]
                    Xc  = mkt_win.drop(columns=[c_target])

                    corr = Xc.corrwith(y_m).abs().sort_values(ascending=False).dropna()
                    corr = corr[[j for j in corr.index if (("XCCY" not in str(j).upper()) and ("BASIS" not in str(j).upper()))]]
                    corr = corr[corr >= float(min_abs_corr)]

                    if not corr.empty:
                        best = corr.index[0]
                        Xr   = Xc[[best]].values.reshape(-1, 1)
                        yvec = y_m.values.reshape(-1, 1)

                        reg = LinearRegression(fit_intercept=False)
                        reg.fit(Xr, yvec)
                        gamma = float(reg.coef_[0][0])
                        r2_score_val = float(reg.score(Xr, yvec))

                        if r2_score_val < float(min_r2):
                            used_proxy = c_target
                            gamma = 1.0
                        else:
                            used_proxy = best

                hedge_units_alpha = (- a_ct * gamma * risk_c) if np.isfinite(risk_c) else np.nan

                bucket_proxy = 'FX' if (("FX" in str(used_proxy).upper()) or (used_proxy in FX_COLS)) \
                               else ('XCCY' if (("XCCY" in str(used_proxy).upper()) or ("BASIS" in str(used_proxy).upper()))
                                     else 'Rates')
                unit_cost = (cost_fx if bucket_proxy=='FX' else (cost_xccy if bucket_proxy=='XCCY' else cost_rate))

                if np.isfinite(hedge_units_alpha) and (target_day in cost_series.index):
                    cost_series.loc[target_day] += abs(hedge_units_alpha) * float(unit_cost)

                plan_rows.append({
                    "Date": target_day,
                    "Constituant": c_target,
                    "Stress": stress_val,
                    "Alpha": a_ct,
                    "Proxy": used_proxy,
                    "Gamma": float(gamma),
                    "R2": float(r2_score_val) if np.isfinite(r2_score_val) else np.nan,
                    "Risk_target": risk_c,
                    "HedgeUnits_alpha": hedge_units_alpha,
                    "Bucket": bucket_proxy,
                    "UnitCost": unit_cost,
                    "CostAlloc": (abs(hedge_units_alpha)*unit_cost) if np.isfinite(hedge_units_alpha) else 0.0,
                })

        # --- Positions persistantes & PnL ---
        plan_df = pd.DataFrame(plan_rows)

        if not plan_df.empty:
            hedge_delta = (
                plan_df.groupby(["Date", "Proxy"])["HedgeUnits_alpha"]
                       .sum().unstack(fill_value=0.0)
                       .reindex(pnl_by_factor.index, fill_value=0.0)
            )
            # aligne colonnes sur facteurs connus
            hedge_delta = hedge_delta.reindex(columns=pnl_by_factor.columns, fill_value=0.0)
            H = hedge_delta.cumsum()
        else:
            H = pd.DataFrame(0.0, index=pnl_by_factor.index, columns=pnl_by_factor.columns)

        E_base = cum_risk.reindex(pnl_by_factor.index).reindex(columns=risk_cols_loc).fillna(0.0)
        driver_series = mkt_change[dtype].reindex(pnl_by_factor.index).fillna(0.0)

        pnl_base  = (E_base.shift(1).mul(driver_series, axis=0)).sum(axis=1).rename("PnL_baseline")
        E_tot     = (E_base.add(H, fill_value=0.0)).shift(1)
        pnl_after = (E_tot.mul(driver_series, axis=0)).sum(axis=1).sub(cost_series, fill_value=0.0).rename("PnL_after")

        cum_base  = pnl_base.cumsum().rename("Cum_Base")
        cum_after = pnl_after.cumsum().rename("Cum_Hedged")

        figF, axF = plt.subplots(figsize=(12,5), dpi=120)
        axF.plot(cum_base.index,  cum_base.values,  label="Cumul Base")
        axF.plot(cum_after.index, cum_after.values, label="Cumul Hedgé")
        axF.legend(); st.pyplot(figF)

        st.subheader("Plan de hedge")
        st.dataframe(
            plan_df.sort_values(["Date","Constituant","Proxy"])
                   .style.format({
                       "Stress":"{:.2f}",
                       "Alpha":"{:.1f}",
                       "Gamma":"{:.3f}",
                       "R2":"{:.3f}",
                       "Risk_target":"{:.0f}",
                       "HedgeUnits_alpha":"{:,.0f}",
                       "UnitCost":"{:.3f}",
                       "CostAlloc":"{:,.0f}"
                   }).applymap(lambda v: 'color:red;' if isinstance(v,(int,float)) and v<0 else '',
                               subset=['Risk_target','HedgeUnits_alpha','CostAlloc']),
            use_container_width=True
        )

    except Exception as e:
        st.warning(f"Erreur Tab3: {e}")
