# =========================
# TAB 3 — Régimes HMM (global) + Hedge par alpha(p_stress) — Positions persistantes
# =========================
with tab3:
    try:
        st.subheader("Régimes (HMM) + Hedge dimensionné par α(p_stress) — Exposition portée")

        # --- Paramètres HMM & Hedge ---
        c1, c2, c3, c4 = st.columns(4)
        with c1:
            hmm_states = st.slider("Nb régimes (HMM)", 2, 6, 3, 1)
        with c2:
            n_iter = st.number_input("n_iter (EM)", 50, 2000, 300, 50)
        with c3:
            topN = st.slider("Top N constituants / jour", 1, 20, 4, 1)
        with c4:
            apply_day = st.selectbox("Appliquer le hedge", ["Jour T", "Jour T+1"], index=0)

        # --- Seuils → α (unique stratégie conservée) ---
        d1, d2, d3 = st.columns(3)
        with d1:
            tau1 = st.slider("Seuil τ1 (→ α=0.3)", 0.0, 1.0, 0.50, 0.05)
        with d2:
            tau2 = st.slider("Seuil τ2 (→ α=0.6)", 0.0, 1.0, 0.70, 0.05)
        with d3:
            tau3 = st.slider("Seuil τ3 (→ α=1.0)", 0.0, 1.0, 0.85, 0.05)

        # --- Coûts de hedge ---
        e1, e2, e3 = st.columns(3)
        with e1:
            cost_rate = st.number_input("Coût — Rates (par DV01)", 0.0, 5.0, 0.20, 0.01)
        with e2:
            cost_xccy = st.number_input("Coût — XCCY (par DV01)", 0.0, 5.0, 0.25, 0.01)
        with e3:
            cost_fx   = st.number_input("Coût — FX (par FX01)",   0.0, 5.0, 0.00, 0.01)

        # --- Cross-hedge controls (XCCY only, market-based gamma) ---
        x1, x2, x3 = st.columns(3)
        with x1:
            use_cross = st.checkbox("Activer cross-hedge (XCCY → proxy Rates/FX)", value=True)
        with x2:
            win_corr  = st.slider("Fenêtre corr (jours)", 20, 180, 60, 5)
        with x3:
            min_abs_corr = st.slider("Seuil |corr| min", 0.0, 1.0, 0.40, 0.05)

        # --- HMM multivarié (global) ---
        from hmmlearn.hmm import GaussianHMM
        from sklearn.preprocessing import StandardScaler

        X_df = pnl_by_factor.copy().replace([np.inf, -np.inf], np.nan).dropna(how="any")
        idx_obs = X_df.index

        scaler = StandardScaler()
        X_use = scaler.fit_transform(X_df.values)

        hmm = GaussianHMM(n_components=int(hmm_states), covariance_type='full', n_iter=int(n_iter), random_state=42)
        hmm.fit(X_use)
        states = pd.Series(hmm.predict(X_use), index=idx_obs, name="state")
        post = pd.DataFrame(hmm.predict_proba(X_use), index=idx_obs)

        net_on_state = pd.concat([net_daily.reindex(idx_obs), states], axis=1).dropna()
        means_by_state = net_on_state.groupby('state')['NetDailyPnL'].mean()
        stress_regime = int(means_by_state.idxmin()) if len(means_by_state)>0 else 0
        p_stress = post.iloc[:, stress_regime].rename("p_stress")  # probabilité de stress (globale)

        # Graphique des régimes
        figR, axR = plt.subplots(figsize=(12,5), dpi=120)
        axR.plot(net_daily.index, net_daily.values, lw=1.1, label='PnL quotidien')
        cmap = plt.cm.get_cmap('tab10', int(hmm_states))
        for s_id in range(int(hmm_states)):
            mask = states == s_id
            axR.fill_between(net_daily.index, net_daily.values, 0,
                             where=mask.reindex(net_daily.index).fillna(False),
                             color=cmap(s_id), alpha=0.12, label=f'Regime {s_id}')
        axR.set_title('HMM multivarié — Régimes (standardisé)')
        axR.legend(loc='upper left', ncols=2)
        st.pyplot(figR)

        # --- Mapping p_stress → α (global, même α pour tous les constituants de la date) ---
        def map_alpha(p: float) -> float:
            if not np.isfinite(p):
                return 0.0
            if p < tau1:  return 0.0
            if p < tau2:  return 0.3
            if p < tau3:  return 0.6
            return 1.0

        # --- Hedge simulation : self-hedge risk-based, positions persistantes ---
        cost_series   = pd.Series(0.0, index=pnl_by_factor.index)
        plan_rows     = []

        def _bucket(name: str) -> str:
            u = str(name).upper()
            if 'FX' in u or (name in FX_COLS): return 'FX'
            if 'XCCY' in u or 'BASIS' in u:     return 'XCCY'
            return 'Rates'

        risk_cols_loc = list(pnl_by_factor.columns)
        risk_ts_loc = risk_ts.reindex(pnl_by_factor.index).reindex(columns=risk_cols_loc)

        for d in pnl_by_factor.index:
            pnl_row = pnl_by_factor.loc[d].reindex(risk_cols_loc)
            top_names = pnl_row.abs().sort_values(ascending=False).head(int(topN)).index.tolist()

            p_d = float(p_stress.reindex(pnl_by_factor.index).get(d, np.nan))
            a_d = map_alpha(p_d)

            target_day = d if apply_day == "Jour T" else (d + pd.Timedelta(days=1))

            # window for correlation on MARKET MOVES (if cross-hedge enabled)
            if use_cross:
                w_start = d - pd.Timedelta(days=int(win_corr)-1)
                window_idx = pnl_by_factor.index[(pnl_by_factor.index >= w_start) & (pnl_by_factor.index <= d)]
                mkt_win = mkt_change.reindex(window_idx).reindex(columns=risk_cols_loc).dropna(how="any")
            else:
                mkt_win = None

            for c_target in top_names:
                risk_c = float(risk_ts_loc.loc[d, c_target]) if (c_target in risk_ts_loc.columns and d in risk_ts_loc.index) else np.nan

                used_proxy = c_target
                gamma = 1.0

                # Cross-hedge only if target bucket is XCCY and window is valid (market-based regression)
                if use_cross and (('XCCY' in str(c_target).upper()) or ('BASIS' in str(c_target).upper())) and (mkt_win is not None) and (len(mkt_win) >= max(15, int(win_corr)//2)) and (c_target in mkt_win.columns):
                    # Market-move co-movements
                    y_m = mkt_win[c_target]
                    Xc  = mkt_win.drop(columns=[c_target])
                    corr = Xc.corrwith(y_m).abs().sort_values(ascending=False).dropna()
                    # keep only Rates & FX as hedgers
                    corr = corr[[j for j in corr.index if (("XCCY" not in str(j).upper()) and ("BASIS" not in str(j).upper()))]]
                    corr = corr[corr >= float(min_abs_corr)]
                    if not corr.empty:
                        best = corr.index[0]
                        from sklearn.linear_model import LinearRegression
                        Xr = Xc[[best]].values.reshape(-1, 1)
                        y_vec = y_m.values.reshape(-1, 1)
                        reg = LinearRegression(fit_intercept=False)
                        reg.fit(Xr, y_vec)
                        gamma = float(reg.coef_[0][0])
                        r2_score_val = float(reg.score(Xr, y_vec))
                        used_proxy = best

                hedge_units_alpha = (- a_d * gamma * risk_c) if np.isfinite(risk_c) else np.nan

                bucket_proxy = 'FX' if (('FX' in str(used_proxy).upper()) or (used_proxy in FX_COLS)) else ('XCCY' if (('XCCY' in str(used_proxy).upper()) or ('BASIS' in str(used_proxy).upper())) else 'Rates')
                unit_cost = (cost_fx if bucket_proxy=='FX' else (cost_xccy if bucket_proxy=='XCCY' else cost_rate))

                if np.isfinite(hedge_units_alpha) and (target_day in cost_series.index):
                    cost_series.loc[target_day] += abs(hedge_units_alpha) * float(unit_cost)

                plan_rows.append({
                    "Date": target_day,
                    "Constituant": c_target,
                    "Stress": p_d,
                    "Alpha": a_d,
                    "Proxy": used_proxy,
                    "Gamma": float(gamma),
                    "R2": float(r2_score_val) if 'r2_score_val' in locals() else np.nan,
                    "R2": float(r2_score_val) if 'r2_score_val' in locals() else np.nan,
                    "Risk_target": risk_c,
                    "HedgeUnits_alpha": hedge_units_alpha,
                    "Bucket": bucket_proxy,
                    "UnitCost": unit_cost,
                    "CostAlloc": (abs(hedge_units_alpha)*unit_cost) if np.isfinite(hedge_units_alpha) else 0.0,
                })

        # Positions de hedge persistantes (overlay DV01/FX01)
        plan_df = pd.DataFrame(plan_rows)
        hedge_delta = plan_df.groupby(["Date","Proxy"])['HedgeUnits_alpha'].sum().unstack(fill_value=0.0)
        hedge_delta = hedge_delta.reindex(pnl_by_factor.index, fill_value=0.0)
        H = hedge_delta.cumsum()

        # PnL en exposition portée × move
        E_base = cum_risk.reindex(pnl_by_factor.index).reindex(columns=risk_cols_loc).fillna(0.0)
        driver_series = mkt_change[dtype].reindex(pnl_by_factor.index).fillna(0.0)

        pnl_base  = (E_base.shift(1).mul(driver_series, axis=0)).sum(axis=1).rename("PnL_baseline")
        E_tot     = (E_base.add(H, fill_value=0.0)).shift(1)
        pnl_after = (E_tot.mul(driver_series, axis=0)).sum(axis=1).sub(cost_series, fill_value=0.0).rename("PnL_after")

        cum_base  = pnl_base.cumsum().rename("Cum_Base")
        cum_after = pnl_after.cumsum().rename("Cum_Hedged")

        figF, axF = plt.subplots(figsize=(12,5), dpi=120)
        axF.plot(cum_base.index,  cum_base.values,  label="Cumul Base")
        axF.plot(cum_after.index, cum_after.values, label="Cumul Hedgé")
        axF.legend(); st.pyplot(figF)

        st.subheader("Plan de hedge")
        st.dataframe(
            plan_df.sort_values(["Date","Constituant","Proxy"])\
                   .style.format({
                       "Stress":"{:.2f}",
                       "Alpha":"{:.1f}",
                       "Gamma":"{:.3f}",
                       "R2":"{:.3f}",
                       "Risk_target":"{:.0f}",
                       "HedgeUnits_alpha":"{:,.0f}",
                       "UnitCost":"{:.3f}",
                       "CostAlloc":"{:,.0f}"
                   }).applymap(lambda v: 'color:red;' if isinstance(v,(int,float)) and v<0 else '',
                               subset=['Risk_target','HedgeUnits_alpha','CostAlloc']),
            use_container_width=True,
        )

    except Exception as e:
        st.warning(f"Erreur Tab3: {e}")
