# =========================
# TAB 3 — HMM + Détection de hedge (τ→α) + Cross-Hedge (XCCY, 1 proxy) + Positions persistantes
# =========================
with tab3:
    try:
        st.subheader("Régimes (HMM) + Détection de hedge + Cross-hedge — Exposition portée")

        # --- Paramètres HMM & Hedge ---
        c1, c2, c3, c4 = st.columns(4)
        with c1:
            hmm_states = st.slider("Nb régimes (HMM)", 2, 6, 3, 1, key="tab3_hmm_states")
        with c2:
            n_iter = st.number_input("n_iter (EM)", 50, 2000, 300, 50, key="tab3_hmm_niter")
        with c3:
            topN = st.slider("Top N constituants / jour", 1, 20, 4, 1, key="tab3_topN")
        with c4:
            apply_day = st.selectbox("Appliquer le hedge", ["Jour T", "Jour T+1"], index=0, key="tab3_apply_day")

        d1, d2, d3 = st.columns(3)
        with d1:
            tau1 = st.slider("Seuil τ1 (→ α=0.3)", 0.0, 1.0, 0.50, 0.05, key="tab3_tau1")
        with d2:
            tau2 = st.slider("Seuil τ2 (→ α=0.6)", 0.0, 1.0, 0.70, 0.05, key="tab3_tau2")
        with d3:
            tau3 = st.slider("Seuil τ3 (→ α=1.0)", 0.0, 1.0, 0.85, 0.05, key="tab3_tau3")

        e1, e2, e3 = st.columns(3)
        with e1:
            cost_rate = st.number_input("Coût — Rates (par DV01)", 0.0, 5.0, 0.20, 0.01, key="tab3_cost_rate")
        with e2:
            cost_xccy = st.number_input("Coût — XCCY (par DV01)", 0.0, 5.0, 0.25, 0.01, key="tab3_cost_xccy")
        with e3:
            cost_fx   = st.number_input("Coût — FX (par FX01)",   0.0, 5.0, 0.00, 0.01, key="tab3_cost_fx")

        # --- Choix du signal qui pilote le hedge ---
        s1, s2 = st.columns([2,1])
        with s1:
            mode_signal = st.selectbox(
                "Signal de hedge",
                ["Global (HMM p_stress)", "Par constituant — Jump (|Δcontrib|/MAD)", "Par constituant — Vol (σ roulante)"],
                index=0, key="tab3_signal_mode"
            )
        with s2:
            win_sig = st.slider("Fenêtre rolling (jours) signal par constituant", 5, 60, 20, 1, key="tab3_win_sig")

        # --- Cross-hedge corrélé (remplace self-hedge si actif pour XCCY) ---
        x1, x2, x3 = st.columns(3)
        with x1:
            use_cross = st.checkbox("Cross-hedge par corrélation (sur RISK) — XCCY uniquement", value=True, key="tab3_xhedge")
        with x2:
            win_corr = st.slider("Fenêtre corr (jours)", 20, 180, 60, 5, key="tab3_win_corr")
        with x3:
            min_abs_corr = st.slider("Seuil |corr| min", 0.0, 1.0, 0.40, 0.05, key="tab3_min_corr")

        # --- HMM multivarié (standardisation obligatoire) ---
        from hmmlearn.hmm import GaussianHMM
        from sklearn.preprocessing import StandardScaler

        X_df = pnl_by_factor.copy().replace([np.inf, -np.inf], np.nan).dropna(how="any")
        idx_obs = X_df.index
        scaler = StandardScaler()
        X_use = scaler.fit_transform(X_df.values)

        hmm = GaussianHMM(n_components=int(hmm_states), covariance_type='full', n_iter=int(n_iter), random_state=42)
        hmm.fit(X_use)
        states = pd.Series(hmm.predict(X_use), index=idx_obs, name="state")
        post = pd.DataFrame(hmm.predict_proba(X_use), index=idx_obs, columns=[f"Regime {i}" for i in range(int(hmm_states))])

        # Régime stress = état à plus faible moyenne de NetDailyPnL
        net_on_state = pd.concat([net_daily.reindex(idx_obs), states], axis=1).dropna()
        means_by_state = net_on_state.groupby('state')['NetDailyPnL'].mean()
        stress_regime = int(means_by_state.idxmin()) if len(means_by_state)>0 else 0
        hmm_proba_stress = post.iloc[:, stress_regime].rename("hmm_proba_stress")

        # Graphique régimes
        figR, axR = plt.subplots(figsize=(12,5), dpi=120)
        axR.plot(net_daily.index, net_daily.values, lw=1.1, label='PnL quotidien')
        cmap = plt.cm.get_cmap('tab10', int(hmm_states))
        for s_id in range(int(hmm_states)):
            mask = states == s_id
            axR.fill_between(net_daily.index, net_daily.values, 0,
                             where=mask.reindex(net_daily.index).fillna(False),
                             color=cmap(s_id), alpha=0.12, label=f'Regime {s_id}')
        auto_xticks(axR, net_daily.index); format_yaxis_plain(axR)
        axR.set_title('HMM multivarié — Régimes (standardisé)')
        axR.legend(loc='upper left', ncols=2)
        st.pyplot(figR)

        # ---------- Détection → α ----------
        eps = 1e-12
        p_stress_series = hmm_proba_stress.reindex(pnl_by_factor.index).ffill().rename("p_stress")

        # Signaux par constituant (jump / vol)
        diff_abs = pnl_by_factor.diff().abs()
        med_rolling = pnl_by_factor.rolling(win_sig, min_periods=max(5, win_sig//2)).median()
        mad_rolling = (pnl_by_factor - med_rolling).abs().rolling(win_sig, min_periods=max(5, win_sig//2)).median()
        sig_jump_df = (diff_abs / (mad_rolling + eps)).apply(lambda s: (s - s.min()) / (s.max() - s.min() + eps))

        std_roll = pnl_by_factor.rolling(win_sig, min_periods=max(5, win_sig//2)).std()
        sig_vol_df = std_roll.apply(lambda s: (s - s.min()) / (s.max() - s.min() + eps))

        def map_to_alpha(series_like: pd.DataFrame) -> pd.DataFrame:
            out = pd.DataFrame(index=series_like.index, columns=series_like.columns, dtype=float)
            out[series_like <  tau1] = 0.0
            out[(series_like >= tau1) & (series_like <  tau2)] = 0.3
            out[(series_like >= tau2) & (series_like <  tau3)] = 0.6
            out[series_like >= tau3] = 1.0
            return out

        if mode_signal == "Global (HMM p_stress)":
            alpha_global = p_stress_series.apply(lambda p: 0.0 if not np.isfinite(p) else (0.0 if p < tau1 else (0.3 if p < tau2 else (0.6 if p < tau3 else 1.0))))
            alpha_df = None
        elif mode_signal == "Par constituant — Jump (|Δcontrib|/MAD)":
            alpha_df = map_to_alpha(sig_jump_df.reindex(pnl_by_factor.index).fillna(0.0)); alpha_global = None
        else:
            alpha_df = map_to_alpha(sig_vol_df.reindex(pnl_by_factor.index).fillna(0.0));  alpha_global = None

        # ---------- Cross-hedge (sur RISK) OU self-hedge ----------
        cost_series   = pd.Series(0.0, index=pnl_by_factor.index)
        plan_rows     = []

        risk_cols_loc = list(pnl_by_factor.columns)

        def _bucket(name: str) -> str:
            u = str(name).upper()
            if 'FX' in u or (name in FX_COLS): return 'FX'
            if 'XCCY' in u or 'BASIS' in u:     return 'XCCY'
            return 'Rates'

        pnl_df = pnl_by_factor.copy()
        risk_ts_loc = risk_ts.reindex(pnl_df.index).reindex(columns=risk_cols_loc)

        for d in pnl_df.index:
            pnl_row = pnl_df.loc[d].reindex(risk_cols_loc)
            # Top N cibles par |PnL| du jour
            top_names = pnl_row.abs().sort_values(ascending=False).head(int(topN)).index.tolist()
            # α par composant (ou global)
            if alpha_df is not None:
                alpha_row = alpha_df.loc[d].reindex(risk_cols_loc).fillna(0.0)
            else:
                a_g = float(alpha_global.get(d, 0.0)) if 'alpha_global' in locals() else 0.0
                alpha_row = pd.Series(a_g, index=risk_cols_loc, dtype=float)

            target_day = d if apply_day == "Jour T" else (d + pd.Timedelta(days=1))

            # Fenêtre corr (RISK) pour cross-hedge XCCY
            if use_cross:
                w_start = d - pd.Timedelta(days=int(win_corr)-1)
                window_idx = pnl_df.index[(pnl_df.index >= w_start) & (pnl_df.index <= d)]
                risk_win = risk_ts_loc.loc[window_idx, risk_cols_loc].dropna(how="any")
            else:
                risk_win = None

            for c_target in top_names:
                a_j = float(alpha_row.get(c_target, 0.0))
                if a_j <= 0.0:
                    continue

                # risk du jour (DV01/FX01) pour la cible
                risk_c = float(risk_ts_loc.loc[d, c_target]) if (c_target in risk_ts_loc.columns and d in risk_ts_loc.index) else np.nan

                if use_cross and (risk_win is not None) and (len(risk_win) >= max(15, int(win_corr)//2)) and _bucket(c_target) == 'XCCY':
                    # Cross-hedge XCCY → choisir 1 seul proxy (meilleure |corr|) parmi Rates & FX
                    if c_target in risk_win.columns:
                        y_r = risk_win[c_target]
                        Xc  = risk_win.drop(columns=[c_target])
                        corr = Xc.corrwith(y_r).abs().sort_values(ascending=False).dropna()
                        corr = corr[corr >= float(min_abs_corr)]
                        corr = corr[[j for j in corr.index if _bucket(j) in ('Rates','FX')]]
                        if not corr.empty:
                            best = corr.index[0]
                            Xr = Xc[[best]]
                            # Ridge fermé (1 hedger -> scalaire)
                            lam = 1e-6
                            XtX = float((Xr.T @ Xr).values) + lam
                            Xty = float((Xr.T @ y_r).values)
                            gamma = Xty / XtX if abs(XtX) > 1e-12 else 0.0

                            risk_target_today = float(risk_ts_loc.loc[d, c_target]) if d in risk_ts_loc.index else np.nan
                            hedge_units = (- a_j * gamma * risk_target_today) if np.isfinite(risk_target_today) else np.nan

                            bucket = _bucket(best)
                            unit_cost = (cost_rate if bucket=='Rates' else (cost_xccy if bucket=='XCCY' else cost_fx))
                            if target_day in cost_series.index and np.isfinite(hedge_units):
                                cost_series.loc[target_day] += abs(hedge_units) * float(unit_cost)

                            plan_rows.append({
                                "Date": target_day, "Mode": "XHEDGE-1",
                                "Constituant_target": c_target, "alpha": a_j,
                                "Risk_target": risk_target_today, "Proxy": best,
                                "Gamma": float(gamma),
                                "HedgeUnits": hedge_units, "Bucket": bucket,
                                "UnitCost": unit_cost,
                                "CostAlloc": (abs(hedge_units)*unit_cost) if np.isfinite(hedge_units) else 0.0
                            })
                            continue  # cross-hedge fait → pas de self en plus

                # Self-hedge (risk-based) par défaut
                hedge_units = (- a_j * risk_c) if np.isfinite(risk_c) else np.nan
                bucket = _bucket(c_target)
                unit_cost = (cost_fx if bucket=='FX' else (cost_xccy if bucket=='XCCY' else cost_rate))
                if target_day in cost_series.index and np.isfinite(hedge_units):
                    cost_series.loc[target_day] += abs(hedge_units) * float(unit_cost)
                plan_rows.append({
                    "Date": target_day, "Mode": "AUTO",
                    "Constituant_target": c_target, "alpha": a_j,
                    "Risk_target": risk_c,
                    "Proxy": c_target, "Gamma": 1.0,
                    "HedgeUnits": hedge_units, "Bucket": bucket,
                    "UnitCost": unit_cost,
                    "CostAlloc": (abs(hedge_units)*unit_cost) if np.isfinite(hedge_units) else 0.0
                })

        # === Positions de hedge persistantes et PnL en exposition portée ===
        plan_df = pd.DataFrame(plan_rows)
        if not plan_df.empty:
            hedge_delta = (
                plan_df.groupby(["Date","Proxy"])['HedgeUnits']
                       .sum().unstack(fill_value=0.0)
                       .reindex(pnl_by_factor.index, fill_value=0.0)
            )
            hedge_delta = hedge_delta.reindex(columns=pnl_by_factor.columns, fill_value=0.0)
            H = hedge_delta.cumsum()
        else:
            H = pd.DataFrame(0.0, index=pnl_by_factor.index, columns=pnl_by_factor.columns)

        E_base = cum_risk.reindex(pnl_by_factor.index).reindex(columns=pnl_by_factor.columns).fillna(0.0)
        driver_series = mkt_change[dtype].reindex(pnl_by_factor.index).fillna(0.0)

        pnl_base  = (E_base.shift(1).mul(driver_series, axis=0)).sum(axis=1).rename("PnL_baseline")
        E_tot     = (E_base.add(H, fill_value=0.0)).shift(1)
        pnl_after = (E_tot.mul(driver_series, axis=0)).sum(axis=1).sub(cost_series, fill_value=0.0).rename("PnL_after")

        cum_base  = pnl_base.cumsum().rename("Cum_Base")
        cum_after = pnl_after.cumsum().rename("Cum_Hedged")

        figF, axF = plt.subplots(figsize=(12,5), dpi=120)
        axF.plot(cum_base.index,  cum_base.values,  label="Cumul Base (exposition portée)")
        axF.plot(cum_after.index, cum_after.values, label="Cumul Hedgé (overlay DV01/FX01)")
        auto_xticks(axF, cum_after.index); format_yaxis_plain(axF)
        axF.set_title("Cumulative PnL — Base vs Hedgé (positions persistantes)")
        axF.legend(loc='upper left')
        st.pyplot(figF)

        k1, k2, k3 = st.columns(3)
        with k1: st.metric("Δ Cumul (Hedgé - Base)", f"{float(cum_after.iloc[-1]-cum_base.iloc[-1]):,.0f}")
        with k2: st.metric("Coût total hedge", f"{float(cost_series.sum()):,.0f}")
        with k3:
            if mode_signal.startswith("Global"):
                pct_days = 100.0*float((p_stress_series.apply(lambda p: 0.0 if p < tau1 else 1.0)).mean())
            else:
                pct_days = 100.0*float((alpha_df.max(axis=1)>0).mean())
            st.metric("% jours couverts", f"{pct_days:.1f}%")

        st.subheader("Plan de hedge (détaillé)")
        if plan_df.empty:
            st.info("Aucun hedge déclenché (seuils non atteints).")
        else:
            st.dataframe(
                plan_df.sort_values(["Date","Constituant_target","Proxy"])\
                       .style.format({
                           "alpha":"{:.2f}",
                           "Risk_target":"{:.0f}",
                           "Gamma":"{:.3f}",
                           "HedgeUnits":"{:,.0f}",
                           "UnitCost":"{:,.3f}",
                           "CostAlloc":"{:,.0f}"
                       }).applymap(lambda v: 'color:red;' if isinstance(v,(int,float)) and v<0 else '',
                                   subset=['Risk_target','HedgeUnits','CostAlloc']),
                use_container_width=True, height=420
            )

        # =========================
        # Calibration des seuils (τ1, τ2, τ3) — grille & courbe
        # =========================
        with st.expander("Calibration des seuils (grid search) : performance vs (τ1, τ2, τ3)", expanded=False):
            colA, colB, colC, colD = st.columns([1,1,1,1])
            with colA:
                t1_min = st.slider("τ1 min", 0.0, 0.7, float(tau1), 0.05)
                t1_max = st.slider("τ1 max", 0.1, 0.8, max(float(tau1)+0.1, 0.6), 0.05)
                n_t1   = st.slider("# points τ1", 2, 6, 3, 1)
            with colB:
                t2_min = st.slider("τ2 min", 0.2, 0.9, float(tau2), 0.05)
                t2_max = st.slider("τ2 max", 0.3, 0.95, max(float(tau2)+0.1, 0.9), 0.05)
                n_t2   = st.slider("# points τ2", 2, 6, 3, 1)
            with colC:
                t3_min = st.slider("τ3 min", 0.4, 0.98, float(tau3), 0.05)
                t3_max = st.slider("τ3 max", 0.5, 0.99, max(float(tau3)+0.1, 0.95), 0.05)
                n_t3   = st.slider("# points τ3", 2, 6, 3, 1)
            with colD:
                metric_choice = st.selectbox("Métrique", ["Δ Cumul", "Sharpe approx"], index=0)

            t1_grid = np.linspace(t1_min, t1_max, int(n_t1))
            t2_grid = np.linspace(t2_min, t2_max, int(n_t2))
            t3_grid = np.linspace(t3_min, t3_max, int(n_t3))

            # mapping → α
            def _alpha_from_thresholds(mode_signal, t1, t2, t3):
                eps = 1e-12
                if mode_signal == "Global (HMM p_stress)":
                    p = hmm_proba_stress.reindex(pnl_by_factor.index).ffill()
                    return p.apply(lambda x: 0.0 if not np.isfinite(x) else (0.0 if x < t1 else (0.3 if x < t2 else (0.6 if x < t3 else 1.0)))), None
                elif mode_signal == "Par constituant — Jump (|Δcontrib|/MAD)":
                    diff_abs = pnl_by_factor.diff().abs()
                    med_rolling = pnl_by_factor.rolling(win_sig, min_periods=max(5, win_sig//2)).median()
                    mad_rolling = (pnl_by_factor - med_rolling).abs().rolling(win_sig, min_periods=max(5, win_sig//2)).median()
                    sig = (diff_abs / (mad_rolling + eps)).fillna(0.0)
                    sig = sig.apply(lambda s: (s - s.min()) / (s.max() - s.min() + eps))
                else:
                    std_roll = pnl_by_factor.rolling(win_sig, min_periods=max(5, win_sig//2)).std()
                    sig = std_roll.apply(lambda s: (s - s.min()) / (s.max() - s.min() + eps)).fillna(0.0)
                alpha_df_loc = pd.DataFrame(index=sig.index, columns=sig.columns, dtype=float)
                alpha_df_loc[sig <  t1] = 0.0
                alpha_df_loc[(sig >= t1) & (sig <  t2)] = 0.3
                alpha_df_loc[(sig >= t2) & (sig <  t3)] = 0.6
                alpha_df_loc[sig >= t3] = 1.0
                return None, alpha_df_loc

            # simulateur (self/cross-hedge identique au dessus, positions persistantes)
            def _simulate(t1, t2, t3):
                alpha_global_loc, alpha_df_loc = _alpha_from_thresholds(mode_signal, t1, t2, t3)
                cost_loc = pd.Series(0.0, index=pnl_by_factor.index)
                plan_rows_loc = []
                risk_cols_loc = list(pnl_by_factor.columns)
                pnl_df_loc = pnl_by_factor.copy()
                risk_ts_loc2 = risk_ts.reindex(pnl_df_loc.index).reindex(columns=risk_cols_loc)

                for d in pnl_df_loc.index:
                    pnl_row = pnl_df_loc.loc[d].reindex(risk_cols_loc)
                    top_names = pnl_row.abs().sort_values(ascending=False).head(int(topN)).index.tolist()
                    if alpha_df_loc is not None:
                        alpha_row = alpha_df_loc.loc[d].reindex(risk_cols_loc).fillna(0.0)
                    else:
                        a_g = float(alpha_global_loc.get(d, 0.0)) if alpha_global_loc is not None else 0.0
                        alpha_row = pd.Series(a_g, index=risk_cols_loc, dtype=float)

                    target_day = d if apply_day == "Jour T" else (d + pd.Timedelta(days=1))

                    if use_cross:
                        w_start = d - pd.Timedelta(days=int(win_corr)-1)
                        window_idx = pnl_df_loc.index[(pnl_df_loc.index >= w_start) & (pnl_df_loc.index <= d)]
                        risk_win = risk_ts_loc2.loc[window_idx, risk_cols_loc].dropna(how="any")
                    else:
                        risk_win = None

                    for c_target in top_names:
                        a_j = float(alpha_row.get(c_target, 0.0))
                        if a_j <= 0.0:
                            continue
                        risk_c = float(risk_ts_loc2.loc[d, c_target]) if (c_target in risk_ts_loc2.columns and d in risk_ts_loc2.index) else np.nan

                        used_proxy = c_target; gamma = 1.0
                        if use_cross and (risk_win is not None) and (len(risk_win) >= max(15, int(win_corr)//2)) and ('XCCY' in str(c_target).upper() or 'BASIS' in str(c_target).upper()):
                            if c_target in risk_win.columns:
                                y_r = risk_win[c_target]
                                Xc  = risk_win.drop(columns=[c_target])
                                corr = Xc.corrwith(y_r).abs().sort_values(ascending=False).dropna()
                                corr = corr[corr >= float(min_abs_corr)]
                                corr = corr[[j for j in corr.index if (('FX' in str(j).upper()) or ('BASIS' not in str(j).upper() and 'XCCY' not in str(j).upper()))]]
                                if not corr.empty:
                                    best = corr.index[0]
                                    Xr = Xc[[best]]
                                    lam = 1e-6
                                    XtX = float((Xr.T @ Xr).values) + lam
                                    Xty = float((Xr.T @ y_r).values)
                                    gamma = Xty / XtX if abs(XtX) > 1e-12 else 0.0
                                    used_proxy = best

                        hedge_units = (- a_j * gamma * risk_c) if np.isfinite(risk_c) else np.nan
                        b = 'FX' if (('FX' in str(used_proxy).upper()) or (used_proxy in FX_COLS)) else ('XCCY' if ('XCCY' in str(used_proxy).upper() or 'BASIS' in str(used_proxy).upper()) else 'Rates')
                        unit_cost = (cost_fx if b=='FX' else (cost_xccy if b=='XCCY' else cost_rate))
                        if target_day in cost_loc.index and np.isfinite(hedge_units):
                            cost_loc.loc[target_day] += abs(hedge_units) * float(unit_cost)
                        plan_rows_loc.append({"Date": target_day, "Proxy": used_proxy, "HedgeUnits": hedge_units})

                plan_df_loc = pd.DataFrame(plan_rows_loc)
                if not plan_df_loc.empty:
                    hedge_delta = plan_df_loc.groupby(["Date","Proxy"])['HedgeUnits'].sum().unstack(fill_value=0.0)
                    hedge_delta = hedge_delta.reindex(pnl_by_factor.index, fill_value=0.0)
                    hedge_delta = hedge_delta.reindex(columns=pnl_by_factor.columns, fill_value=0.0)
                    H_loc = hedge_delta.cumsum()
                else:
                    H_loc = pd.DataFrame(0.0, index=pnl_by_factor.index, columns=pnl_by_factor.columns)

                E_base_loc = cum_risk.reindex(pnl_by_factor.index).reindex(columns=pnl_by_factor.columns).fillna(0.0)
                driver_series = mkt_change[dtype].reindex(pnl_by_factor.index).fillna(0.0)
                pnl_base_loc  = (E_base_loc.shift(1).mul(driver_series, axis=0)).sum(axis=1)
                pnl_after_loc = ((E_base_loc.add(H_loc).shift(1)).mul(driver_series, axis=0)).sum(axis=1).sub(cost_loc, fill_value=0.0)

                if metric_choice == "Δ Cumul":
                    return float(pnl_after_loc.cumsum().iloc[-1] - pnl_base_loc.cumsum().iloc[-1])
                else:  # Sharpe approx
                    r = pnl_after_loc - pnl_after_loc.mean()
                    s = r.std(ddof=1)
                    return float(r.mean() / s) if s and np.isfinite(s) else np.nan

            # grille
            rows = []
            for t1_ in t1_grid:
                for t2_ in t2_grid:
                    for t3_ in t3_grid:
                        if not (t1_ < t2_ < t3_):
                            continue
                        score = _simulate(t1_, t2_, t3_)
                        rows.append({"tau1": t1_, "tau2": t2_, "tau3": t3_, "score": score})
            grid_df = pd.DataFrame(rows).dropna().sort_values("score", ascending=False)

            st.write("Top combinaisons")
            st.dataframe(grid_df.head(15).style.format({"tau1":"{:.2f}", "tau2":"{:.2f}", "tau3":"{:.2f}", "score":"{:.0f}" if metric_choice=="Δ Cumul" else "{:.3f}"}), use_container_width=True)

            # Courbe : fixer τ1, τ2 courants et balayer τ3
            sweep_t3 = np.linspace(max(float(tau2)+0.01, t3_min), t3_max, int(max(3, n_t3)))
            curve = [ _simulate(float(tau1), float(tau2), t3_) for t3_ in sweep_t3 ]
            figC, axC = plt.subplots(figsize=(10,4), dpi=120)
            axC.plot(sweep_t3, curve, marker='o')
            axC.set_xlabel("τ3 (τ1, τ2 fixés)"); axC.set_ylabel(metric_choice)
            axC.set_title("Courbe de performance vs τ3")
            st.pyplot(figC)

    except Exception as _e_tab3:
        st.warning(f"Tab 3 (HMM + détection + cross-hedge) non rendue: {_e_tab3}")
