# ============================================================
# TAB 3 — Optimized HMM • Signals • Cross-Hedge • DV01→FX01
# ============================================================

with tab3:

    st.subheader("Régimes (HMM) • Détection Hedge • Cross-Hedge • Positions persistantes (Optimisé)")

    # --------------------------------------------------------
    # (0) UI PARAMS
    # --------------------------------------------------------
    c1, c2, c3, c4 = st.columns(4)
    with c1:
        hmm_states = st.slider("Nb régimes (HMM)", 2, 6, 3, 1)
    with c2:
        n_iter = st.number_input("n_iter (EM)", 50, 2000, 300, 50)
    with c3:
        topN = st.slider("Top N constituants par jour", 1, 20, 4)
    with c4:
        apply_day = st.selectbox("Appliquer hedge", ["Jour T", "Jour T+1"], index=0)

    d1, d2, d3 = st.columns(3)
    with d1: tau1 = st.slider("τ1 (α=0.3)", 0.0, 1.0, 0.50, 0.05)
    with d2: tau2 = st.slider("τ2 (α=0.6)", 0.0, 1.0, 0.70, 0.05)
    with d3: tau3 = st.slider("τ3 (α=1.0)", 0.0, 1.0, 0.85, 0.05)

    e1, e2, e3 = st.columns(3)
    with e1: cost_rate = st.number_input("Cost Rates (par DV01)", 0.0, 5.0, 0.20)
    with e2: cost_xccy = st.number_input("Cost XCCY (par DV01)", 0.0, 5.0, 0.25)
    with e3: cost_fx = st.number_input("Cost FX (par FX01)", 0.0, 5.0, 0.00)

    s1, s2 = st.columns([2,1])
    with s1:
        mode_signal = st.selectbox(
            "Signal de hedge",
            ["Global (p_stress)",
             "Par constituant — Jump",
             "Par constituant — Vol",
             "Changement de régime"]
        )
    with s2:
        win_sig = st.slider("Fenêtre signal", 5, 60, 20)

    x1, x2, x3 = st.columns(3)
    with x1: use_cross = st.checkbox("Cross-hedge marché ΔMkt", True)
    with x2: win_corr = st.slider("Fenêtre corr marché", 20, 180, 60)
    with x3: min_abs_corr = st.slider("Seuil |corr| min", 0.0, 1.0, 0.40)

    dv01fx_win = st.slider("Fenêtre β (DV01→FX01)", 20, 180, 60)

    # --------------------------------------------------------
    # (1) PRE-ALIGNMENT (Huge speedup)
    # --------------------------------------------------------
    idx = pnl_by_factor.index
    pnl_df = pnl_by_factor.reindex(idx)
    risk_df = risk_ts.reindex(idx).reindex(columns=pnl_df.columns)
    driver = mkt_change[dtype].reindex(idx).fillna(0.0)
    cost_series = pd.Series(0.0, index=idx)

    # --------------------------------------------------------
    # (2) HMM – fully optimized
    # --------------------------------------------------------
    from hmmlearn.hmm import GaussianHMM
    from sklearn.preprocessing import StandardScaler
    from sklearn.linear_model import LinearRegression
    import numpy as np

    X = pnl_df.replace([np.inf,-np.inf],np.nan).dropna()
    scaler = StandardScaler()
    Z = scaler.fit_transform(X.values)

    hmm = GaussianHMM(hmm_states, covariance_type='full', n_iter=n_iter, random_state=42)
    hmm.fit(Z)

    states = pd.Series(hmm.predict(Z), index=X.index)
    post = pd.DataFrame(hmm.predict_proba(Z),
                        index=X.index,
                        columns=[f"Regime {i}" for i in range(hmm_states)])

    net_clean = net_daily.reindex(X.index)
    mstate = pd.concat([net_clean, states], axis=1).dropna()
    stress_regime = int(mstate.groupby("state")["NetDailyPnL"].mean().idxmin())

    p_stress = post[f"Regime {stress_regime}"].reindex(idx).ffill()

    # --------------------------------------------------------
    # (3) SIGNALS → ALPHA (vectorized)
    # --------------------------------------------------------
    eps = 1e-12

    def map_to_alpha(v):
        if v < tau1: return 0.0
        if v < tau2: return 0.3
        if v < tau3: return 0.6
        return 1.0

    if mode_signal == "Global (p_stress)":
        alpha_global = p_stress.apply(map_to_alpha)
        alpha_df = None

    elif mode_signal == "Changement de régime":
        r_change = states.reindex(idx).ne(states.reindex(idx).shift(1))
        alpha_global = r_change.astype(float)
        alpha_df = None

    else:
        # Jump & Vol — vectorized
        med = pnl_df.rolling(win_sig).median()
        diff_med = (pnl_df - med).abs()
        mad = diff_med.rolling(win_sig).median()

        if mode_signal == "Par constituant — Jump":
            s = (pnl_df.diff().abs() / (mad + eps))
        else:
            s = pnl_df.rolling(win_sig).std()

        # normalize factor by factor
        s = (s - s.min()) / (s.max() - s.min() + eps)
        alpha_df = s.applymap(map_to_alpha)
        alpha_global = None

    # --------------------------------------------------------
    # (4) DV01→FX01 Beta (cached)
    # --------------------------------------------------------
    from functools import lru_cache

    @lru_cache(maxsize=4096)
    def get_beta(rate_col, fx_col, date_str, win):
        end = pd.to_datetime(date_str)
        start = end - pd.Timedelta(days=win-1)
        w = mkt_change.loc[start:end]

        if rate_col not in w.columns or fx_col not in w.columns:
            return (np.nan, np.nan)

        r = w[rate_col] * 1e-4
        f = w[fx_col] * 1e-2
        df = pd.concat([r.rename("r"), f.rename("fx")], axis=1).dropna()

        if df.empty or df["r"].std()==0 or df["fx"].std()==0:
            return (np.nan, np.nan)

        rho = df["r"].corr(df["fx"])
        beta = rho * (df["r"].std() / df["fx"].std())
        return float(rho), float(beta)

    def bucket(c):
        cu = c.upper()
        if "FX" in cu or c in FX_COLS: return "FX"
        if "XCCY" in cu or "BASIS" in cu: return "XCCY"
        return "Rates"

    # --------------------------------------------------------
    # (5) PRECOMPUTE mkt_corr windows (massive speed gain)
    # --------------------------------------------------------
    if use_cross:
        mkt_valid = mkt_change.reindex(idx).reindex(columns=pnl_df.columns)
        # Rolling corr by factor vs factor kept simple due to heavy cost
    else:
        mkt_valid = None

    # --------------------------------------------------------
    # (6) HEDGE LOOP (highly optimized)
    # --------------------------------------------------------
    plan_rows = []

    idx_list = list(idx)
    cols = list(pnl_df.columns)

    for d in idx_list:
        i_alpha = (alpha_df.loc[d] if alpha_df is not None
                   else pd.Series(alpha_global.get(d,0.0), index=cols))

        row = pnl_df.loc[d]
        top = row.abs().nlargest(topN).index

        # market window for cross
        if use_cross:
            start = d - pd.Timedelta(days=win_corr-1)
            w = mkt_valid.loc[start:d].dropna(how="any")
            ok_cross = not w.empty
        else:
            w = None
            ok_cross = False

        tday = d if apply_day=="Jour T" else (d + pd.Timedelta(days=1))

        for c in top:
            α = i_alpha[c]
            if α <= 0: continue

            dv01 = risk_df.at[d, c] if np.isfinite(risk_df.at[d, c]) else np.nan
            used = c
            gamma = 1.0

            # CROSS-HEDGE XCCY
            if ok_cross and bucket(c)=="XCCY" and c in w.columns:
                y = w[c]
                Xc = w.drop(columns=[c])
                corr = Xc.corrwith(y).abs().sort_values(ascending=False)
                corr = corr[[k for k in corr.index if bucket(k) in ("Rates","FX")]]
                corr = corr[corr >= min_abs_corr]

                if not corr.empty:
                    best = corr.index[0]
                    Xr = Xc[[best]].values.reshape(-1,1)
                    yr = y.values.reshape(-1,1)
                    reg = LinearRegression(fit_intercept=False)
                    reg.fit(Xr, yr)
                    gamma = float(reg.coef_[0][0])
                    used = best

            B = bucket(used)
            unit_cost = cost_rate if B=="Rates" else (cost_xccy if B=="XCCY" else cost_fx)

            # -------------------------------
            # FX XHEDGE — DV01→FX01
            # -------------------------------
            extra = {"Rho":np.nan, "Beta":np.nan, "FX01_equiv":np.nan}

            if used != c and B=="FX" and np.isfinite(dv01):
                rho, beta = get_beta(c, used, str(d.date()), dv01fx_win)
                if np.isfinite(beta):
                    fx01 = dv01 * beta * 100.0
                    h = -α * fx01
                    extra = {"Rho":rho, "Beta":beta, "FX01_equiv":fx01}
                else:
                    h = -α * gamma * dv01
            else:
                h = -α * gamma * dv01 if np.isfinite(dv01) else np.nan

            # cost in T
            if np.isfinite(h):
                cost_series.at[tday] += abs(h) * unit_cost

            plan_rows.append({
                "Date": tday,
                "Mode": ("XHEDGE-1" if used!=c else "AUTO"),
                "Constituant_target": c,
                "alpha": α,
                "Risk_target": dv01,
                "Proxy": used,
                "Bucket": B,
                "Gamma": gamma,
                "HedgeUnits": h,
                "UnitCost": unit_cost,
                "CostAlloc": abs(h)*unit_cost if np.isfinite(h) else 0.0,
                **extra
            })

    plan_df = pd.DataFrame(plan_rows)

    # --------------------------------------------------------
    # (7) POSITIONS & PNL (vectorized, fastest)
    # --------------------------------------------------------
    if not plan_df.empty:
        HΔ = (
            plan_df.groupby(["Date","Proxy"])["HedgeUnits"]
                   .sum().unstack(fill_value=0.0)
                   .reindex(idx, fill_value=0.0)
        ).reindex(columns=cols, fill_value=0.0)
    else:
        HΔ = pd.DataFrame(0.0, index=idx, columns=cols)

    H = HΔ.cumsum()

    E0 = cum_risk.reindex(idx).reindex(columns=cols).fillna(0.0)
    base = (E0.shift(1)*driver[:,None]).sum(axis=1)
    after = ((E0+H).shift(1)*driver[:,None]).sum(axis=1) - cost_series

    cbase = base.cumsum()
    cafter = after.cumsum()

    # --------------------------------------------------------
    # (8) PLOT
    # --------------------------------------------------------
    fig, ax = plt.subplots(figsize=(12,5), dpi=120)
    ax.plot(cbase, label="Cumul Base")
    ax.plot(cafter, label="Cumul Hedgé")
    ax.legend()
    st.pyplot(fig)

    # --------------------------------------------------------
    # (9) METRICS
    # --------------------------------------------------------
    k1,k2,k3 = st.columns(3)
    with k1: st.metric("Δ Cumul", f"{float(cafter.iloc[-1]-cbase.iloc[-1]):,.0f}")
    with k2: st.metric("Coût total", f"{float(cost_series.sum()):,.0f}")
    with k3:
        pct = 100*((alpha_df.max(axis=1)>0).mean() if alpha_df is not None else (alpha_global>0).mean())
        st.metric("% jours couverts", f"{pct:.1f}%")

    # --------------------------------------------------------
    # (10) TABLE
    # --------------------------------------------------------
    st.subheader("Plan de hedge (détaillé — Optimisé)")

    if plan_df.empty:
        st.info("Aucun hedge déclenché.")
    else:
        fmt = {
            "alpha":"{:.2f}", "Risk_target":"{:.0f}", "Gamma":"{:.3f}",
            "HedgeUnits":"{:,.0f}", "UnitCost":"{:.3f}", "CostAlloc":"{:,.0f}",
            "Rho":"{:.3f}", "Beta":"{:.3f}", "FX01_equiv":"{:,.0f}"
        }
        st.dataframe(
            plan_df.sort_values(["Date","Constituant_target","Proxy"]).style.format(fmt),
            use_container_width=True, height=420
        )
