# =========================
# TAB 3 — KNN (détection de changements de régime) + Hedges (−PnL/ΔS)
# =========================
try:
    from sklearn.cluster import KMeans
    from sklearn.neighbors import KNeighborsClassifier
    from sklearn.preprocessing import StandardScaler
    from matplotlib.ticker import FuncFormatter

    st.header("KNN — Détection de changements de régime & Hedges (Total scénarios)")

    # ---- Hyperparams & inputs ----
    c1, c2, c3, c4, c5 = st.columns(5)
    with c1:
        n_clusters = st.slider("K des régimes (pré‑étiquetage)", 2, 10, 3, 1, key="knn_rc_K")
    with c2:
        n_neighbors = st.slider("k voisins (KNN)", 1, 25, 7, 1, key="knn_rc_k")
    with c3:
        top_n = st.slider("Top N constituants par date", 1, 20, 4, 1, key="knn_rc_topn")
    with c4:
        alpha_cov = st.slider("α — % à couvrir", 0, 100, 100, 5, key="knn_rc_alpha")/100.0
    with c5:
        mode_dates = st.selectbox("Dates à hedger", ["Tous les changements", "Entrées en régime défavorable seulement"], index=0, key="knn_rc_mode")

    # ---- Coeff_total (∑ scénarios) & DV01/FX01 per‑unit (info) ----
    coeff_cols = [c for c in coeff_df.columns if str(c) != "DataType"]
    coeff_total = (
        coeff_df.set_index("DataType")[coeff_cols]
        .astype(float)
        .sum(axis=1)
        .reindex(risk_cols)
    )
    bump_s = (
        mapping_df.reindex(risk_cols)["Bump"]
        .astype(float)
        .where(lambda s: s.notna() & (s != 0.0))
    )
    dv01_per_unit = (coeff_total / bump_s).replace([np.inf, -np.inf], np.nan)

    # ---- Features & pre‑labels (KMeans) ----
    X = pnl_by_factor.fillna(0.0)
    scaler = StandardScaler(); Xz = scaler.fit_transform(X)
    km = KMeans(n_clusters=int(n_clusters), n_init=10, random_state=42)
    km_labels = pd.Series(km.fit_predict(Xz), index=X.index, name='km_cluster')

    # Map clusters en bon/mauvais via le PnL net moyen
    tmp = pd.concat([net_daily, km_labels], axis=1).dropna()
    stats = tmp.groupby('km_cluster')['NetDailyPnL'].mean()
    bad_clusters = set(stats.index[stats < 0])
    y_signed = km_labels.map(lambda L: -1 if L in bad_clusters else 1)

    # ---- KNN sur Xz pour lisser & détecter changements ----
    knn = KNeighborsClassifier(n_neighbors=int(n_neighbors))
    knn.fit(Xz, y_signed)
    y_hat = pd.Series(knn.predict(Xz), index=X.index, name='regime')

    # Détections de changements (inclut toutes transitions)
    changes = []
    prev = None
    for dt, lab in y_hat.items():
        if prev is None:
            prev = lab
            continue
        if lab != prev:
            if (mode_dates == "Entrées en régime défavorable seulement" and lab < 0) or (mode_dates == "Tous les changements"):
                changes.append(dt)
        prev = lab

    # ---- Plot régimes + changements ----
    figR, axR = plt.subplots(figsize=(12,5), dpi=120)
    axR.plot(net_daily.index, net_daily.values, lw=1.1, label='PnL quotidien')
    axR.fill_between(net_daily.index, net_daily.values, 0,
                     where=(y_hat.reindex(net_daily.index).fillna(1).values < 0),
                     color='red', alpha=0.18, label='Régime défavorable')
    if len(changes):
        axR.vlines(changes, ymin=min(float(net_daily.min()),0.0), ymax=max(float(net_daily.max()),0.0),
                    linestyles=':', color='red', alpha=0.5, label='Changement de régime')
    axR.yaxis.set_major_formatter(FuncFormatter(lambda v,_: f"{v:,.0f}"))
    # Axe X adaptatif
    npts=len(net_daily)
    if npts<120:
        locx=mdates.MonthLocator(interval=1); fmtx=mdates.DateFormatter('%b %Y')
    elif npts<300:
        locx=mdates.MonthLocator(interval=3); fmtx=mdates.DateFormatter('%b %Y')
    elif npts<700:
        locx=mdates.MonthLocator(interval=6); fmtx=mdates.DateFormatter('%b %Y')
    else:
        locx=mdates.YearLocator(); fmtx=mdates.DateFormatter('%Y')
    axR.xaxis.set_major_locator(locx); axR.xaxis.set_major_formatter(fmtx)
    axR.set_title('KNN — Régimes & changements (rouge = défavorable)')
    axR.legend(loc='upper left')
    st.pyplot(figR)

    # ---- Table Top‑N par changement (hedge = −PnL/ΔS, fallback −PnL/Bump) ----
    rows = []
    for d in changes:
        if d not in pnl_by_factor.index:
            continue
        pnl_row = pnl_by_factor.loc[d].reindex(risk_cols)
        dS_row  = mkt_change.loc[d].reindex(risk_cols) if d in mkt_change.index else pd.Series(index=risk_cols, dtype=float)
        topN = pnl_row.abs().sort_values(ascending=False).head(int(top_n)).index.tolist()
        for c in topN:
            pnl_c = float(pnl_row.get(c, np.nan))
            dS_i  = float(dS_row.get(c, np.nan))
            bump_c = float(bump_s.get(c, np.nan))
            coeff_tot_c = float(coeff_total.get(c, np.nan))
            dv01_unit_c = float(dv01_per_unit.get(c, np.nan))
            # Hedge priorité ΔS
            if np.isfinite(dS_i) and abs(dS_i) > 1e-12:
                hedge_100 = -(pnl_c / dS_i)
                logic = "−PnL/ΔS"
            elif np.isfinite(bump_c) and abs(bump_c) > 1e-12:
                hedge_100 = -(pnl_c / bump_c)
                logic = "−PnL/Bump (fallback)"
            else:
                hedge_100 = np.nan
                logic = "n/a"
            hedge_alpha = hedge_100 * float(alpha_cov) if np.isfinite(hedge_100) else np.nan
            rows.append({
                "Date": d,
                "Constituant": c,
                "PnL_contrib": pnl_c,
                "ΔS (move observé)": dS_i,
                "Bump (Mapping)": bump_c,
                "Coeff_total (∑ scénarios)": coeff_tot_c,
                "DV01/FX01 per-unit (Coeff_total/Bump)": dv01_unit_c,
                "Hedge100% (−PnL/ΔS)": hedge_100,
                "Hedge(α×)": hedge_alpha,
                "Logic": logic,
            })

    tbl_entries = pd.DataFrame(rows)
    if not tbl_entries.empty:
        tbl_entries["AbsPnL"] = tbl_entries["PnL_contrib"].abs()
        tbl_entries = tbl_entries.sort_values(["Date","AbsPnL"], ascending=[True, False]).drop(columns=["AbsPnL"])

    st.subheader("Changements & Hedges proposés (−PnL/ΔS)")
    if tbl_entries.empty:
        st.info("Aucun changement détecté ou données insuffisantes.")
    else:
        st.dataframe(
            tbl_entries.style.format({
                "PnL_contrib":"{:,.0f}",
                "ΔS (move observé)":"{:,.6f}",
                "Bump (Mapping)":"{:,.6f}",
                "Coeff_total (∑ scénarios)":"{:,.0f}",
                "DV01/FX01 per-unit (Coeff_total/Bump)":"{:,.0f}",
                "Hedge100% (−PnL/ΔS)":"{:,.0f}",
                "Hedge(α×)":"{:,.0f}",
            }).applymap(lambda v: 'color:red;' if isinstance(v,(int,float)) and v<0 else '', subset=['PnL_contrib','Hedge100% (−PnL/ΔS)','Hedge(α×)']),
            use_container_width=True
        )
        st.download_button(
            "Télécharger (CSV) — Changements & Hedges (KNN)",
            data=tbl_entries.to_csv(index=False).encode('utf-8'),
            file_name=f"knn_changes_hedges_total_{dtype}.csv",
            mime="text/csv",
        )

    # =========================
    # Coût & PnL net (réutilise tbl_entries)
    # =========================
    st.subheader("Coût de hedge et PnL net (Total scénarios)")
    if not tbl_entries.empty:
        c1, c2, c3 = st.columns(3)
        cost_rate = c1.number_input("Coût — Rates (par DV01)", 0.0, 5.0, 0.20, 0.01, key="cost_rate_knn_rc")
        cost_xccy = c2.number_input("Coût — XCCY (par DV01)", 0.0, 5.0, 0.25, 0.01, key="cost_xccy_knn_rc")
        cost_fx   = c3.number_input("Coût — FX (par FX01)",   0.0, 5.0, 0.00, 0.01, key="cost_fx_knn_rc")

        def _bucket(name: str) -> str:
            n = str(name).upper()
            if 'FX' in n or (('FX_COLS' in globals()) and (name in FX_COLS)):
                return 'FX'
            if 'XCCY' in n or 'BASIS' in n:
                return 'XCCY'
            return 'Rates'

        cost_series = pd.Series(0.0, index=net_daily.index)
        for d, sub in tbl_entries.groupby('Date'):
            tot = 0.0
            for _, r in sub.iterrows():
                units_alpha = r.get('Hedge(α×)', np.nan)
                if not np.isfinite(units_alpha) or units_alpha == 0:
                    continue
                b = _bucket(r.get('Constituant',''))
                if b == 'FX':
                    tot += abs(units_alpha) * float(cost_fx)
                elif b == 'XCCY':
                    tot += abs(units_alpha) * float(cost_xccy)
                else:
                    tot += abs(units_alpha) * float(cost_rate)
            if d in cost_series.index:
                cost_series.loc[d] += tot

        contrib_after = pnl_by_factor.copy()
        for d, sub in tbl_entries.groupby('Date'):
            if d not in contrib_after.index:
                continue
            cols = sub['Constituant'].unique().tolist()
            contrib_after.loc[d, cols] = contrib_after.loc[d, cols] * (1.0 - float(alpha_cov))

        pnl_base  = pnl_by_factor.sum(axis=1).rename('PnL_baseline')
        pnl_hedge = (contrib_after.sum(axis=1) - cost_series).rename('PnL_hedged_net')
        cum_base, cum_hedge = pnl_base.cumsum(), pnl_hedge.cumsum()

        fig_net, ax_net = plt.subplots(figsize=(12,5), dpi=120)
        ax_net.plot(cum_base.index, cum_base.values, label='Baseline')
        ax_net.plot(cum_hedge.index, cum_hedge.values, label='Hedged (net coût)')
        if len(changes):
            ax_net.vlines(changes,
                          ymin=min(float(cum_base.min()), float(cum_hedge.min())),
                          ymax=max(float(cum_base.max()), float(cum_hedge.max())),
                          linestyles=':', color='red', alpha=0.35, label='Changements')
        ax_net.yaxis.set_major_formatter(FuncFormatter(lambda v,_: f"{v:,.0f}"))
        # Axe X adaptatif
        npts=len(cum_base)
        if npts<120:
            locx=mdates.MonthLocator(interval=1); fmtx=mdates.DateFormatter('%b %Y')
        elif npts<300:
            locx=mdates.MonthLocator(interval=3); fmtx=mdates.DateFormatter('%b %Y')
        elif npts<700:
            locx=mdates.MonthLocator(interval=6); fmtx=mdates.DateFormatter('%b %Y')
        else:
            locx=mdates.YearLocator(); fmtx=mdates.DateFormatter('%Y')
        ax_net.xaxis.set_major_locator(locx); ax_net.xaxis.set_major_formatter(fmtx)
        ax_net.set_title('Cumulative PnL — Baseline vs Hedged (net coût) — KNN changements')
        ax_net.legend(loc='upper left')
        st.pyplot(fig_net)

        tot_cost = float(cost_series.sum())
        pnl_diff = float(cum_hedge.iloc[-1] - cum_base.iloc[-1])
        k1, k2 = st.columns(2)
        with k1: st.metric("Coût total hedge", f"{tot_cost:,.0f}")
        with k2: st.metric("Δ PnL cumulé (Hedged - Baseline)", f"{pnl_diff:,.0f}")
    else:
        st.info("Table vide — aucun coût/graphique à afficher.")
except Exception as _e_knn_rc:
    st.warning(f"Tab 3 (KNN changements) non rendue: {_e_knn_rc}") non rendus: {_e_knn_cost_total}")
